rf3_fit <- ranger(
formula = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio +valor_comercial,
data = RF_train,
num.trees = 500,
mtry = floor(sqrt(ncol(RF_train))),
min.node.size = 5,
importance = "impurity"
)
predicciones_RF <- predict(rf2_fit, data = df_test)$predictions
predicciones_RF <- data.frame(
property_id = df_test$property_id,
price = predicciones
)
predicciones_RF <- predict(rf2_fit, data = df_test)$predictions
predicciones_RF <- data.frame(
property_id = df_test$property_id,
price = predicciones_RF
)
predicciones_RF <- data.frame(
property_id = df_test$property_id,
price = predicciones_RF
)
predicciones_RF <- predict(rf3_fit, data = df_test)$predictions
predicciones_RF <- data.frame(
property_id = df_test$property_id,
price = predicciones
)
predicciones_RF <- predict(rf3_fit, newdata = df_test)
predicciones_RF <- predict(rf3_fit, data = df_test)
predicciones_RF <- data.frame(
property_id = df_test$property_id,
price = predicciones_RF  # Aquí usas `predicciones_RF` en lugar de `predicciones`
)
# Guardar en un archivo CSV
write.csv(predicciones_RF, "RF_M3.csv", row.names = FALSE)
sqrt(ncol(RF_train)
x->sqrt(ncol(RF_train)
# **4. Definir grilla de hiperparámetros**
grid_rf <- expand.grid(
mtry = c(3, 5, 7, floor(sqrt(ncol(RF_train)))),
num.trees = c(100, 500, 1000),
min.node.size = c(1, 5, 10)
)
# **5. Configuración de validación cruzada**
ctrl_rf <- trainControl(
method = "cv",
number = 5,
verboseIter = TRUE
)
# **8. Ajustar el modelo final con los mejores hiperparámetros**
rf_final <- ranger(
formula = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio + valor_comercial,
data = RF_train,
num.trees = best_params$num.trees,
mtry = best_params$mtry,
min.node.size = best_params$min.node.size,
importance = "impurity"
)
library(tidymodels)
# **8. Ajustar el modelo final con los mejores hiperparámetros**
rf_final <- ranger(
formula = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio + valor_comercial,
data = RF_train,
num.trees = best_params$num.trees,
mtry = best_params$mtry,
min.node.size = best_params$min.node.size,
importance = "impurity"
)
# **7. Mostrar los mejores hiperparámetros**
best_params <- rf_tuned$bestTune
best_params <- rf_tuned$bestTune
# **4. Definir grilla de hiperparámetros**
grid_rf <- expand.grid(
mtry = c(3, 5, 7, floor(sqrt(ncol(RF_train)))),
num.trees = c(100, 500, 1000),
min.node.size = c(1, 5, 10)
)
# **5. Configuración de validación cruzada**
ctrl_rf <- trainControl(
method = "cv",
number = 5,
verboseIter = TRUE
)
# **6. Ajustar el modelo con búsqueda de hiperparámetros**
rf_tuned <- train(
price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio + valor_comercial,
data = RF_train,
method = "ranger",
trControl = ctrl_rf,
tuneGrid = grid_rf,
importance = "impurity"
)
# **4. Definir grilla de hiperparámetros**
grid_rf <- expand.grid(
mtry = c(3, 5, 7, floor(sqrt(ncol(RF_train)))),
num.trees = c(100, 500, 1000),
min.node.size = c(1, 5, 10)
)
# **5. Configuración de validación cruzada**
ctrl_rf <- trainControl(
method = "cv",
number = 5,
verboseIter = TRUE
)
# **6. Ajustar el modelo con búsqueda de hiperparámetros**
rf_tuned <- train(
price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio + valor_comercial,
data = RF_train,
method = "ranger",
trControl = ctrl_rf,
tuneGrid = grid_rf,
importance = "impurity"
)
# **4. Definir grilla de hiperparámetros**
grid_rf <- expand.grid(
mtry = c(3, 5, 7, floor(sqrt(ncol(RF_train)))),
splitrule = c("variance", "extratrees"),  # Include splitrule!
min.node.size = c(1, 5, 10)
)
# **5. Configuración de validación cruzada**
ctrl_rf <- trainControl(
method = "cv",
number = 5,
verboseIter = TRUE
)
# **6. Ajustar el modelo con búsqueda de hiperparámetros**
rf_tuned <- train(
price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio + valor_comercial,
data = RF_train,
method = "ranger",
trControl = ctrl_rf,
tuneGrid = grid_rf,
importance = "impurity"
)
# **7. Mostrar los mejores hiperparámetros**
best_params <- rf_tuned$bestTune
print(best_params)
# **7. Mostrar los mejores hiperparámetros**
best_params <- rf_tuned$bestTune
best_params <- rf_tuned$bestTune
print(best_params)
best_params <- rf_tuned$bestTune
print(best_params)
# **8. Ajustar el modelo final con los mejores hiperparámetros**
rf_final <- ranger(
formula = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio + valor_comercial,
data = RF_train,
num.trees = best_params$num.trees,
mtry = best_params$mtry,
min.node.size = best_params$min.node.size,
importance = "impurity"
)
# **8. Ajustar el modelo final con los mejores hiperparámetros**
rf_final <- ranger(
formula = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio + valor_comercial,
data = RF_train,
num.trees = 500,
mtry = best_params$mtry,
min.node.size = best_params$min.node.size,
importance = "impurity"
)
# **9. Predicción en datos de prueba**
df_test <- df %>% filter(grupo == "test")
df_test_preprocesado <- bake(prepped_rf, new_data = df_test)
predicciones_RF <- predict(rf_final, data = df_test_preprocesado)$predictions
predicciones_RF <- data.frame(
property_id = df_test$property_id,
price = predicciones_RF
)
# **10. Guardar resultados**
write.csv(predicciones_RF, "RF_Tuned.csv", row.names = FALSE)
formulas <- list(
modelo1 = price ~ surface_imputado + bathrooms + rooms + bedrooms + estudio + parqueadero + distancia_college,
modelo2 = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio +valor_comercial,
modelo3= price ~ surface_imputado + rooms + bathrooms + property_type + piso + codigo_barrio + valor_comercial + walkin_closet + lujos
)
gb_train <- df %>% filter(grupo == "train") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, terraza,
seguridad, piso, distancia_commercial, walkin_closet,
cocina_lujo, distancia_cafe, patio_lavanderia,
saloncomunal_recepcion, distancia_bank, distancia_bus_station,
year, property_type, cocina_estandar, sala_comedor, lujos, remodelado,
codigo_localidad, valor_comercial)
class(gb_train)
formulas <- list(
modelo1 = price ~ surface_imputado + bathrooms + rooms + bedrooms + estudio + parqueadero + distancia_college,
modelo2 = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio +valor_comercial,
modelo3= price ~ surface_imputado + rooms + bathrooms + property_type + piso + codigo_barrio + valor_comercial + walkin_closet + lujos
)
gb_train <- df %>% filter(grupo == "train") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos)
class(gb_train)
prepped_gb <- prep(rec_gb, training = gb_train)
rec_gb <- recipe(price ~ ., data = gb_train) |>
step_normalize(all_numeric_predictors()) |>  # Normaliza todas las variables numéricas
step_dummy(all_nominal_predictors()) |>  # Convierte variables categóricas en dummies
step_novel(all_nominal_predictors()) |>  # Maneja categorías desconocidas en nuevas observaciones
step_zv(all_predictors())
prepped_gb <- prep(rec_gb, training = gb_train)
gb_train <- bake(prepped_gb, new_data = gb_train)
#datos espaciales
gb_train_sf <- st_as_sf(
gb_train,
coords = c("geometry"),  # Usa tu columna espacial
crs = 4326
)
gb_train <- df %>% filter(grupo == "train") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos, geometry)
View(df)
load("Datos_limpios.RData")
load("Datos_limpios.RData")
names(cols(df))
colnames(df)
gb_train <- df %>% filter(grupo == "train") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos, geometry)
formulas <- list(
modelo1 = price ~ surface_imputado + bathrooms + rooms + bedrooms + estudio + parqueadero + distancia_college,
modelo2 = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio +valor_comercial,
modelo3= price ~ surface_imputado + rooms + bathrooms + property_type + piso + codigo_barrio + valor_comercial + walkin_closet + lujos
)
class(gb_train)
formulas <- list(
modelo1 = price ~ surface_imputado + bathrooms + rooms + bedrooms + estudio + parqueadero + distancia_college,
modelo2 = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio +valor_comercial,
modelo3= price ~ surface_imputado + rooms + bathrooms + property_type + piso + codigo_barrio + valor_comercial + walkin_closet + lujos
)
gb_train <- df %>% filter(grupo == "train") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos, geometry)
class(gb_train)
rec_gb<- as.data.frame(df_sf)
rec_gb<- as.data.frame(df)
rec_gb <- recipe(price ~ ., data = gb_train) |>
step_normalize(all_numeric_predictors()) |>
step_dummy(all_nominal_predictors()) |>
step_novel(all_nominal_predictors()) |>
step_zv(all_predictors())
prepped_gb <- prep(rec_gb, training = gb_train)
formulas <- list(
modelo1 = price ~ surface_imputado + bathrooms + rooms + bedrooms + estudio + parqueadero + distancia_college,
modelo2 = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio +valor_comercial,
modelo3= price ~ surface_imputado + rooms + bathrooms + property_type + piso + codigo_barrio + valor_comercial + walkin_closet + lujos
)
gb_data <- df|> st_drop_geometry()
gb_train <- gb_data %>% filter(grupo == "train") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos, geometry)
gb_train <- gb_data %>% filter(grupo == "train") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos)
gb_train <- gb_data %>% filter(grupo == "train") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos)
class(gb_train)
rec_gb <- recipe(price ~ ., data = gb_train) |>
step_normalize(all_numeric_predictors()) |>
step_dummy(all_nominal_predictors()) |>
step_novel(all_nominal_predictors()) |>
step_zv(all_predictors())
prepped_gb <- prep(rec_gb, training = gb_train)
gb_train <- bake(prepped_gb, new_data = gb_train)
#B. Modelos
grid_gbm <- expand.grid(
interaction.depth = c(3, 5, 7),
n.trees = c(100, 300, 500),
shrinkage = c(0.01, 0.1, 0.3),
n.minobsinnode = c(5, 10, 20)
)
ctrl_gbm <- trainControl(method = "cv", number = 5, verboseIter = TRUE)
for (nombre in names(formulas)) {
gbm_tuned <- train(
formulas[[nombre]],
data = gb_train,
method = "gbm",
tuneGrid = grid_gbm,
metric = "MAE",
trControl = ctrl_gbm
)
best_mae <- min(gbm_tuned$results$MAE)
resultados <- rbind(resultados, data.frame(modelo = nombre, MAE = best_mae))
}
formulas <- list(
modelo1 = price ~ surface_imputado + bathrooms + rooms + bedrooms  + parqueadero + distancia_college,
modelo2 = price ~ surface_imputado + bathrooms + bedrooms + parqueadero + distancia_hospital + distancia_marketplace + codigo_barrio +valor_comercial,
modelo3= price ~ surface_imputado + rooms + bathrooms + property_type + piso + codigo_barrio + valor_comercial + walkin_closet + lujos
)
#B. Modelos
grid_gbm <- expand.grid(
interaction.depth = c(3, 5, 7),
n.trees = c(100, 300, 500),
shrinkage = c(0.01, 0.1, 0.3),
n.minobsinnode = c(5, 10, 20)
)
ctrl_gbm <- trainControl(method = "cv", number = 5, verboseIter = TRUE)
resultados <- data.frame(modelo = character(), MAE = numeric())
for (nombre in names(formulas)) {
gbm_tuned <- train(
formulas[[nombre]],
data = gb_train,
method = "gbm",
tuneGrid = grid_gbm,
metric = "MAE",
trControl = ctrl_gbm
)
best_mae <- min(gbm_tuned$results$MAE)
resultados <- rbind(resultados, data.frame(modelo = nombre, MAE = best_mae))
}
colnames(gb_data)
str(gb_data$parqueadero)  # Revisa si es numérico, categórico o tiene valores extraños
gb_train <- gb_data %>% filter(grupo == "train") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos)
class(gb_train)
rec_gb <- recipe(price ~ ., data = gb_train) |>
step_normalize(all_numeric_predictors()) |>
step_dummy(all_nominal_predictors()) |>
step_novel(all_nominal_predictors()) |>
step_zv(all_predictors())
prepped_gb <- prep(rec_gb, training = gb_train)
gb_train <- bake(prepped_gb, new_data = gb_train)
colnames(gb_train_preprocesado)
colnames(gb_train)
#B. Modelos
formulas <- list(
modelo1 = price ~ surface_imputado + bathrooms + rooms + bedrooms + parqueadero_Sí + distancia_college,
modelo2 = price ~ surface_imputado + bathrooms + bedrooms + parqueadero_Sí + distancia_hospital + distancia_marketplace + codigo_barrio + valor_comercial,
modelo3 = price ~ surface_imputado + rooms + bathrooms + property_type_Casa + piso + codigo_barrio + valor_comercial + walkin_closet_Sí + lujos_Sí
)
grid_gbm <- expand.grid(
interaction.depth = c(3, 5, 7),
n.trees = c(100, 300, 500),
shrinkage = c(0.01, 0.1, 0.3),
n.minobsinnode = c(5, 10, 20)
)
ctrl_gbm <- trainControl(method = "cv", number = 5, verboseIter = TRUE)
resultados <- data.frame(modelo = character(), MAE = numeric())
for (nombre in names(formulas)) {
gbm_tuned <- train(
formulas[[nombre]],
data = gb_train,
method = "gbm",
tuneGrid = grid_gbm,
metric = "MAE",
trControl = ctrl_gbm
)
best_mae <- min(gbm_tuned$results$MAE)
resultados <- rbind(resultados, data.frame(modelo = nombre, MAE = best_mae))
}
# Ordenar por menor MAE
resultados <- resultados[order(resultados$MAE), ]
print(resultados)
# Ordenar por menor MAE
resultados <- resultados[order(resultados$MAE), ]
print(resultados)
sum(is.na(gb_train))  # Debe ser 0 antes de entrenar
gb_train[which(rowSums(is.na(gb_train)) > 0), ]
colSums(is.na(gb_train))
gb_train <- gb_train %>% na.omit()
gb_train <- gb_train %>% na.omit()
class(gb_train)
rec_gb <- recipe(price ~ ., data = gb_train) |>
step_normalize(all_numeric_predictors()) |>
step_dummy(all_nominal_predictors()) |>
step_novel(all_nominal_predictors()) |>
step_zv(all_predictors())
prepped_gb <- prep(rec_gb, training = gb_train)
gb_train <- bake(prepped_gb, new_data = gb_train)
colnames(gb_train)
#B. Modelos
formulas <- list(
modelo1 = price ~ surface_imputado + bathrooms + rooms + bedrooms + parqueadero_Sí + distancia_college,
modelo2 = price ~ surface_imputado + bathrooms + bedrooms + parqueadero_Sí + distancia_hospital + distancia_marketplace + codigo_barrio + valor_comercial,
modelo3 = price ~ surface_imputado + rooms + bathrooms + property_type_Casa + piso + codigo_barrio + valor_comercial + walkin_closet_Sí + lujos_Sí
)
grid_gbm <- expand.grid(
interaction.depth = c(3, 5, 7),
n.trees = c(100, 300, 500),
shrinkage = c(0.01, 0.1, 0.3),
n.minobsinnode = c(5, 10, 20)
)
ctrl_gbm <- trainControl(method = "cv", number = 5, verboseIter = TRUE)
resultados <- data.frame(modelo = character(), MAE = numeric())
for (nombre in names(formulas)) {
gbm_tuned <- train(
formulas[[nombre]],
data = gb_train,
method = "gbm",
tuneGrid = grid_gbm,
metric = "MAE",
trControl = ctrl_gbm
)
best_mae <- min(gbm_tuned$results$MAE)
resultados <- rbind(resultados, data.frame(modelo = nombre, MAE = best_mae))
}
# Ordenar por menor MAE
resultados <- resultados[order(resultados$MAE), ]
print(resultados)
mejor_modelo <- resultados$modelo[1]  # Selecciona el modelo con menor MAE
mejores_parametros <- gbm_tuned$bestTune  # Extrae los mejores hiperparámetros
print(mejor_modelo)
print(mejores_parametros)
gbm_final <- train(
formulas[[mejor_modelo]],
data = gb_train,
method = "gbm",
metric = "MAE",
trControl = ctrl_gbm,
tuneGrid = mejores_parametros
)
gb_test <- gb_data %>% filter(grupo == "test")
gb_test <- bake(prepped_gb, new_data = gb_test)  # Preprocesar los datos de prueba
gb_test <- bake(prepped_gb, data = gb_test)  # Preprocesar los datos de prueba
gb_test <- gb_data %>% filter(grupo == "test")
gb_test <- bake(prepped_gb,data = gb_test)  # Preprocesar los datos de prueba
gb_test <- bake(prepped_gb,new_data = gb_test)
gb_test <- gb_data %>% filter(grupo == "test")
View(gb_test)
gb_test <- gb_data %>% filter(grupo == "test")
gb_test <- bake(prepped_gb,new_data = gb_test)
gb_test <- bake(prepped_gb, new_data = gb_test, composition = "predictors")
gb_test <- gb_data %>% filter(grupo == "test")
rec_gb <- recipe(price ~ ., data = gb_test) |>
step_normalize(all_numeric_predictors()) |>
step_dummy(all_nominal_predictors()) |>
step_novel(all_nominal_predictors()) |>
step_zv(all_predictors())
gb_test <- bake(prepped_gb,new_data = gb_test)
gb_test <- bake(rec_gb,new_data = gb_test)
rec_gb <- recipe(price ~ ., data = gb_test) |>
step_normalize(all_numeric_predictors()) |>
step_dummy(all_nominal_predictors()) |>
step_novel(all_nominal_predictors()) |>
step_zv(all_predictors())
prepped_gb_test <- prep(rec_gb, training = gb_test)
gb_test <- bake(prepped_gb_test, new_data = gb_test)
gb_test <- gb_data %>% filter(grupo == "test")
rec_gb <- recipe(price ~ ., data = gb_test) |>
step_normalize(all_numeric_predictors()) |>
step_dummy(all_nominal_predictors()) |>
step_novel(all_nominal_predictors()) |>
step_zv(all_predictors())
prepped_gb_test <- prep(rec_gb, training = gb_test)
rlang::last_trace()
gb_test <- gb_data %>% filter(grupo == "test")
View(gb_test)
gb_test <- gb_data %>% filter(grupo == "test") %>%
select(price, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos)
rec_gb <- recipe(price ~ ., data = gb_test) |>
step_normalize(all_numeric_predictors()) |>
step_dummy(all_nominal_predictors()) |>
step_novel(all_nominal_predictors()) |>
step_zv(all_predictors())
prepped_gb_test <- prep(rec_gb, training = gb_test)
gb_test <- bake(prepped_gb_test, new_data = gb_test)
predicciones_gbm <- predict(gbm_final, newdata = gb_test)
# Crear dataframe con resultados
resultado_predicciones <- gb_test %>%
select(property_id) %>%
mutate(price = predicciones_gbm)
gb_test <- gb_data %>% filter(grupo == "test") %>%
select(price,property_id, surface_imputado, bathrooms, rooms,
bedrooms, estudio, parqueadero, distancia_college,
distancia_hospital, distancia_marketplace, piso,
codigo_barrio, valor_comercial, property_type,
walkin_closet, lujos)
rec_gb <- recipe(price ~ ., data = gb_test) |>
step_normalize(all_numeric_predictors()) |>
step_dummy(all_nominal_predictors()) |>
step_novel(all_nominal_predictors()) |>
step_zv(all_predictors())
prepped_gb_test <- prep(rec_gb, training = gb_test)
# Guardar resultados
write.csv(resultado_predicciones, "GBM_Final.csv", row.names = FALSE)
# Crear dataframe con resultados
resultado_predicciones <- gb_test %>%
select(property_id) %>%
mutate(price = predicciones_gbm)
# Guardar resultados
write.csv(resultado_predicciones, "GBM_Final.csv", row.names = FALSE)
