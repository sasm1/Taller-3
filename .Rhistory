p_load(tidyverse, # Dataframes
rio,
plotly, # Gráficos interactivos
leaflet, # Mapas interactivos
units, # unidades
sf, # Leer/escribir/manipular datos espaciales
osmdata, # OpenStreetMap (OSM)
tidymodels,
randomForest, # Bosques
rattle, # Interfaz gráfica para el modelado de datos
spatialsample,
xgboost, # Muestreo espacial para modelos de aprendizaje automático
tmaptools,
terra,
geojsonR,
stringi, # Manipulación de texto
tm, # Stop word
SnowballC, # Reeducir palabras a su raíz (Stemming)
wordcloud, # Nube de palabras
RColorBrewer)
gc()
cat('\014')
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Librerias ---------------------------------------------------------------
require(pacman)
p_load(tidyverse, # Dataframes
rio,
plotly, # Gráficos interactivos
leaflet, # Mapas interactivos
units, # unidades
sf, # Leer/escribir/manipular datos espaciales
osmdata, # OpenStreetMap (OSM)
tidymodels,
randomForest, # Bosques
rattle, # Interfaz gráfica para el modelado de datos
spatialsample,
xgboost, # Muestreo espacial para modelos de aprendizaje automático
tmaptools,
terra,
geojsonR,
stringi, # Manipulación de texto
tm, # Stop word
SnowballC, # Reeducir palabras a su raíz (Stemming)
wordcloud, # Nube de palabras
RColorBrewer)
# Directorios -------------------------------------------------------------
data <- paste0(getwd(),'/Data/') # Directorio de base de datos
# Lectura de datos --------------------------------------------------------
train <- read_csv(paste0(data,'train.csv'))
test  <- read_csv(paste0(data,'test.csv'))
# Etiquetas ---------------------------------------------------------------
test <- test %>%
mutate(grupo ='test')%>%
select(grupo, everything()) #(2)
train <- train%>%
mutate(grupo = 'train')%>%
select(grupo, everything()) #(1)
# Data completa ----------------------------------------------------
df <- bind_rows(train, test)
write_csv(df, paste0(data,"df.csv"))
rm(train,test)
#---------------------------------------------------------
# LIMPIEZA DE BASES DE DATOS
#---------------------------------------------------------
summary(df)
apply(df, 2, function(x) sum(is.na(x)))
apply(df, 2, function(x) round(sum(is.na(x)/length(x))*100,2))
View(df)
summarize(df)
summary(df)
p_load(tidyverse, # Dataframes
rio,
plotly, # Gráficos interactivos
leaflet, # Mapas interactivos
units, # unidades
sf, # Leer/escribir/manipular datos espaciales
osmdata, # OpenStreetMap (OSM)
tidymodels,
randomForest, # Bosques
rattle, # Interfaz gráfica para el modelado de datos
spatialsample,
xgboost, # Muestreo espacial para modelos de aprendizaje automático
tmaptools,
terra,
geojsonR,
stringi, # Manipulación de texto
tm, # Stop word
SnowballC, # Reeducir palabras a su raíz (Stemming)
wordcloud, # Nube de palabras
RColorBrewer,
geosphere)
# ---- Trasmi
tm_stations <- opq(bbox = "Bogotá, Colombia") %>%
add_osm_feature(key = "public_transport", value = "station") %>%
osmdata_sf()
# Filtra solo las estaciones que tienen nombre relacionado con TransMilenio
estaciones_tm <- tm_stations$osm_points %>%
filter(grepl("TransMilenio", name, ignore.case = TRUE)) %>%
select(name, geometry)
propiedades_sf <- st_as_sf(df, coords = c("lon", "lat"), crs = 4326)
# Extraer coordenadas
coords_prop <- st_coordinates(propiedades_sf)
coords_tm <- st_coordinates(estaciones_tm)
# Calcular matriz de distancias (cada fila es una propiedad, cada columna una estación)
dist_matrix <- geosphere::distm(coords_prop, coords_tm)  # en metros
nrow(propiedades_sf)  # ¿Tiene propiedades?
nrow(estaciones_tm)   # ¿Se cargaron estaciones de TM?
tm_osm <- opq("Bogotá, Colombia") %>%
add_osm_feature(key = "highway", value = "bus_stop") %>%
osmdata_sf()
estaciones_tm <- tm_osm$osm_points
# Extraer coordenadas
coords_prop <- st_coordinates(propiedades_sf)
coords_tm <- st_coordinates(estaciones_tm)
nrow(propiedades_sf)  # ¿Tiene propiedades?
nrow(estaciones_tm)   # ¿Se cargaron estaciones de TM?
plot(st_geometry(estaciones_tm), main = "Estaciones de bus (incluye TM)")
dist_matrix <- geosphere::distm(coords_prop, coords_tm)
dist_min <- apply(dist_matrix, 1, min)
plot(st_geometry(estaciones_tm), main = "Estaciones de bus (incluye TM)")
df$dist_tm_metros <- dist_min
df
#Parques cercanos
# Obtenemos los parques desde OSM
parques_osm <- opq("Bogotá, Colombia") %>%
add_osm_feature(key = "leisure", value = "park") %>%
osmdata_sf()
parques <- parques_osm$osm_polygons %>% select(geometry)
parques_osm <- opq("Bogotá, Colombia") %>%
add_osm_feature(key = "leisure", value = "park") %>%
osmdata_sf()
parques <- parques_osm$osm_polygons %>% select(geometry)
propiedades_sf <- st_as_sf(df, coords = c("lon", "lat"), crs = 4326)
# Usar EPSG: 3116 (MAGNA-SIRGAS Bogotá) o 3857 (Web Mercator)
propiedades_sf <- st_transform(propiedades_sf, crs = 3857)
parques <- st_transform(parques, crs = 3857)
buffer <- st_buffer(propiedades_sf, dist = 500)
intersecciones <- st_intersects(buffer, parques)
num_parques <- lengths(intersecciones)
# Usar EPSG: 3116 (MAGNA-SIRGAS Bogotá) o 3857 (Web Mercator)
propiedades_sf <- st_transform(propiedades_sf, crs = 3116)
parques <- st_transform(parques, crs = 3116)
# Usamos 3116
propiedades_sf <- st_transform(propiedades_sf, crs = 3116)
parques <- st_transform(parques, crs = 3116)
#Usamos radio de 500 metros
buffer <- st_buffer(propiedades_sf, dist = 500)
intersecciones <- st_intersects(buffer, parques)
conteo <- lengths(intersecciones)
df$num_parques <- conteo
ggplot() +
geom_sf(data = parques, fill = "lightgreen", color = "darkgreen", alpha = 0.5) +
geom_sf(data = propiedades_sf, color = "red", size = 2) +
theme_minimal() +
labs(title = "Parques y Propiedades en Bogotá",
subtitle = "Datos de OpenStreetMap",
caption = "Fuente: OSM")
#####opt 2
# Calculamos el centroide de cada parque para aproximar su ubciacion como un solo punto
centroides <- st_centroid(parques, byid = T)
centroides <- centroides %>%
mutate(x=st_coordinates(centroides)[, "X"]) %>%
mutate(y=st_coordinates(centroides)[, "Y"])
# Crear el mapa interactivo
mapa <- leaflet() %>%
addTiles() %>%  # Agrega un fondo base de OpenStreetMap
addCircleMarkers(data = centroides,
~x, ~y,
color = "blue",
radius = 5,
popup = ~paste("Centroide Parque")) %>%
addCircleMarkers(data = propiedades_sf,
color = "red",
radius = 4,
popup = ~paste("Propiedad"))
# Mostrar el mapa
mapa
leaflet() %>%
addTiles() %>%
addPolygons(data = parques, color = "green", fillOpacity = 0.5) %>%
addCircleMarkers(data = propiedades_sf, color = "red", radius = 4)
parques <- st_transform(parques, crs = 3116) # CRS para Bogotá
propiedades_sf <- st_transform(propiedades_sf, crs = 3116)
# Calculamos los centroides correctamente
centroides <- st_centroid(parques)
# Extraer coordenadas sin errores
centroides_coords <- st_coordinates(centroides)
centroides <- centroides %>%
mutate(x = centroides_coords[, 1],
y = centroides_coords[, 2])
# Crear el mapa en Leaflet
leaflet() %>%
addTiles() %>%
addCircleMarkers(data = centroides, ~x, ~y, color = "blue", radius = 5, popup = "Centroide Parque") %>%
addCircleMarkers(data = propiedades_sf, color = "red", radius = 4, popup = "Propiedad")
st_crs(parques)
# Calculamos los centroides correctamente
centroides <- st_centroid(st_transform(parques, crs = 3116))
print(centroides)
# Crear el mapa en Leaflet
# Transformamos los centroides al sistema EPSG:4326 para leaflet
centroides <- st_transform(centroides, crs = 4326)
# Extraemos correctamente las coordenadas
centroides_coords <- st_coordinates(centroides)
centroides <- centroides %>%
mutate(lon = centroides_coords[, 1],
lat = centroides_coords[, 2])
# Transformamos también las propiedades
propiedades_sf <- st_transform(propiedades_sf, crs = 4326)
# Mapa en leaflet con coordenadas correctas
leaflet() %>%
addTiles() %>%
addCircleMarkers(data = centroides,
~lon, ~lat,
color = "blue",
radius = 5,
popup = "Centroide Parque") %>%
addCircleMarkers(data = propiedades_sf,
color = "red",
radius = 4,
popup = "Propiedad")
p_load(tidyverse, # Dataframes
rio,
plotly, # Gráficos interactivos
leaflet, # Mapas interactivos
units, # unidades
sf, # Leer/escribir/manipular datos espaciales
osmdata, # OpenStreetMap (OSM)
tidymodels,
randomForest, # Bosques
rattle, # Interfaz gráfica para el modelado de datos
spatialsample,
xgboost, # Muestreo espacial para modelos de aprendizaje automático
tmaptools,
terra,
geojsonR,
stringi, # Manipulación de texto
tm, # Stop word
SnowballC, # Reeducir palabras a su raíz (Stemming)
wordcloud, # Nube de palabras
RColorBrewer,
geosphere)
# Lectura de datos --------------------------------------------------------
train <- read_csv(paste0(data,'train.csv'))
test  <- read_csv(paste0(data,'test.csv'))
# Directorios -------------------------------------------------------------
data <- paste0(getwd(),'/Data/') # Directorio de base de datos
# Lectura de datos --------------------------------------------------------
train <- read_csv(paste0(data,'train.csv'))
test  <- read_csv(paste0(data,'test.csv'))
# Etiquetas ---------------------------------------------------------------
test <- test %>%
mutate(grupo ='test')%>%
select(grupo, everything()) #(2)
train <- train%>%
mutate(grupo = 'train')%>%
select(grupo, everything()) #(1)
# Data completa ----------------------------------------------------
df <- bind_rows(train, test)
write_csv(df, paste0(data,"df.csv"))
rm(train,test)
#---------------------------------------------------------
# LIMPIEZA DE BASES DE DATOS
#---------------------------------------------------------
summary(df)
apply(df, 2, function(x) sum(is.na(x)))
apply(df, 2, function(x) round(sum(is.na(x)/length(x))*100,2))
####Variables externas####
# ---- Distancia de transporte público
tm_osm <- opq("Bogotá, Colombia") %>%
add_osm_feature(key = "highway", value = "bus_stop") %>%
osmdata_sf()
estaciones_tm <- tm_osm$osm_points
propiedades_sf <- st_as_sf(df, coords = c("lon", "lat"), crs = 4326)
coords_prop <- st_coordinates(propiedades_sf)
coords_tm <- st_coordinates(estaciones_tm)
dist_matrix <- geosphere::distm(coords_prop, coords_tm)
dist_min <- apply(dist_matrix, 1, min)
plot(st_geometry(estaciones_tm), main = "Estaciones de bus (incluye TM)")
df$dist_tm_metros <- dist_min
df
parques_osm <- opq("Bogotá, Colombia") %>%
add_osm_feature(key = "leisure", value = "park") %>%
osmdata_sf()
parques <- parques_osm$osm_polygons %>% select(geometry) %>%
st_transform(crs = 4326)
propiedades_sf <- st_as_sf(df, coords = c("lon", "lat"), crs = 4326)
buffer <- st_buffer(propiedades_sf, dist = 500)
df$num_parques <- lengths(st_intersects(buffer, parques))
centroides <- st_centroid(parques) %>%
mutate(lon = st_coordinates(.)[, 1], lat = st_coordinates(.)[, 2])
# Crear el mapa
leaflet() %>%
addTiles() %>%
addCircleMarkers(data = centroides, ~lon, ~lat, color = "blue", radius = 5, popup = "Centroide Parque")
# Calcular centroides de los parques
centroides <- st_centroid(parques) %>%
mutate(lon = st_coordinates(.)[, 1], lat = st_coordinates(.)[, 2])
# Calcular la matriz de distancias entre propiedades y parques
dist_matrix <- st_distance(propiedades_sf, parques)
# Convertir la matriz en un data frame para análisis
dist_df <- as.data.frame(dist_matrix)
dim(dist_matrix)
dist_min <- apply(dist_matrix, 1, min)
db <- db %>% mutate(distancia_min_parque = dist_min)
df <- df %>% mutate(distancia_min_parque = dist_min)
p <- ggplot(db, aes(x = distancia_parque)) +
geom_histogram(bins = 50, fill = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros", y = "Cantidad",
title = "Distribución de la distancia a los parques") +
theme_bw()
p <- ggplot(df, aes(x = distancia_parque)) +
geom_histogram(bins = 50, fill = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros", y = "Cantidad",
title = "Distribución de la distancia a los parques") +
theme_bw()
ggplotly(p)
p <- ggplot(df, aes(x = distancia_min_parque)) +
geom_histogram(bins = 50, fill = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros", y = "Cantidad",
title = "Distribución de la distancia a los parques") +
theme_bw()
ggplotly(p)
View(df)
#Relación variable de interés
#Vamos a tomar una muestra dada la cantidad de los datos
p <- ggplot(db%>%sample_n(1000), aes(x = distancia_min_parque, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
#Relación variable de interés
#Vamos a tomar una muestra dada la cantidad de los datos
p <- ggplot(df%>%sample_n(1000), aes(x = distancia_min_parque, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
ggplotly(p)
#Relación variable de interés
#Vamos a tomar una muestra dada la cantidad de los datos
p <- ggplot(df%>%sample_n(1000), aes(x = num_parques, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
ggplotly(p)
#Relación variable de interés
#Vamos a tomar una muestra dada la cantidad de los datos
p <- ggplot(df%>%sample_n(5000), aes(x = num_parques, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
ggplotly(p)
p <- ggplot(db%>%sample_n(1000), aes(x = dist_tm_metros, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
p <- ggplot(df%>%sample_n(1000), aes(x = dist_tm_metros, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
ggplotly(p)
p <- ggplot(df%>%sample_n(1000), aes(x = dist_tm_metros, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
ggplotly(p)
p <- ggplot(df%>%sample_n(1000), aes(x = dist_tm_metros, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
ggplotly(p)
p <- ggplot(df%>%sample_n(5000), aes(x = dist_tm_metros, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
ggplotly(p)
#---- Densidad de servicios
# Descargar datos de servicios para todo Bogotá (una sola vez)
tags = {'amenity': ['restaurant', 'cafe', 'bank', 'pharmacy', 'supermarket',
bogota = ox.geocode_to_gdf('Bogotá, Colombia')
#---- Densidad de servicios
# Obtener servicios y comercios de OSM
servicios <- opq("Bogotá, Colombia") %>%
add_osm_feature(key = "amenity",
value = c("restaurant", "cafe", "bank", "pharmacy",
"supermarket", "school", "hospital", "marketplace")) %>%
osmdata_sf()
# Extraer puntos de servicios
puntos_servicios <- servicios$osm_points
# Función para calcular densidad de servicios (radio de 800m)
calcular_densidad <- function(geom, servicios, radio = 800) {
buffer <- st_buffer(geom, dist = radio)
servicios_dentro <- st_intersects(buffer, servicios, sparse = FALSE)
return(sum(servicios_dentro))
}
# Calcular y añadir la densidad para cada propiedad
df$service_density <- sapply(st_geometry(propiedades_sf),
function(geom) calcular_densidad(geom, puntos_servicios))
# Extraer puntos de servicios
puntos_servicios <- servicios$osm_points
# Método más rápido: crear buffers para todas las propiedades a la vez
radio <- 800  # metros
todos_buffers <- st_buffer(propiedades_sf, dist = radio)
# Usar st_intersects para calcular todas las intersecciones de una vez
intersecciones <- st_intersects(todos_buffers, puntos_servicios)
# Contar el número de intersecciones para cada propiedad
df$service_density <- lengths(intersecciones)
# Ver resultado
head(df)
p <- ggplot(df%>%sample_n(5000), aes(x = service_density, y = price)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor de venta  (log-scale)",
title = "Relación entre la proximidad a un parque y el precio del immueble") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
ggplotly(p)
# Limpiar environment -----------------------------------------------------
rm(list = ls())
gc()
cat('\014')
install.packages("rstudioapi")
# Cargar paquetes ---------------------------------------------------------
library(pacman)
# Cargar las librerías listadas e instalarlas en caso de ser necesario
p_load(tidyverse, # Manipular dataframes
stringi, # Manipular cadenas de texto
rio, # Importar datos fácilmente
sf, # Leer/escribir/manipular datos espaciales
tidymodels, # entrenamiento de modelos
spatialsample, # Muestreo espacial para modelos de aprendizaje automático
rsample, # Resamplear los datos
dplyr,
parsnip, # elastic net
dials, # elastic net tunning
recipies, # Recetas
workflows)   # Crear worklows RN
# Cargar los datos --------------------------------------------------------
load("Datos_limpios.RData")
# Cargar los datos --------------------------------------------------------
load("temporal.RData")
